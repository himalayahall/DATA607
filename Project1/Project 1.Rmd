---
title: "Project 1"
author: "Jawaid Hakim"
date: "`r Sys.Date()`"
output:
     
  pdf_document: 
    toc: true
    toc_depth: 3
    number_sections: true
  html_document:
    
    toc: true
    toc_depth: 3
    toc_float: true
    number_sections: true
boxlinks: true
urlcolor: blue
always_allow_html: true
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE, warning=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
```

# Solution

## Read tournament data

Read input data. Since we will be extracting rows/columns we can convert to matrix format for easier downstream processing.

```{r}
input_matrix <- read.csv("https://raw.githubusercontent.com/himalayahall/DATA607/main/Project1/tournamentinfo.txt")
input_matrix <- matrix(unlist(input_matrix))
```

## Data preparation

We notice the first 3 rows are header rows and don't contain player info.

```{r}
head(input_matrix, n = 10)
```

Skip first 3 header rows.

```{r skip-header-rows}
input_matrix <- input_matrix[-1:-3]
head(input_matrix, n = 6)
```

Data for a player is provided on 2 rows. First row gives the name of player and games played by them. The second row gives the State and initial rank of the player. For any given player, the 2 data rows appear consecutively, followed by a dashed separator line.    

Using this observation, we split the input matrix into 2 components.  

The 1^st^ component will contain player name, total number of points, and games played by them. We can extract this data by starting at row 1 and scooping up every 3^rd^ row from the input matrix (skipping over state/rank and separator line).  

```{r players-and-games}
mPlayersAndGames <- input_matrix[seq(1, length(input_matrix), 3)]
head(mPlayersAndGames, n = 5)
```

The 2^nd^ component will contain player State and pre-rating. We extract this data by starting at row 2 and, as before, scooping up every 3^rd^ row from the input matrix (skipping over the separator line and next player's name).

```{r player-states-and-ranks}
mStatesAndRanks <- input_matrix[seq(2, length(input_matrix), 3)]
head(mStatesAndRanks, n = 5)
```

## Generate static player data

At this point we have the necessary components to generate static data for each player - player id, name, state, total points, and pre-rating.  

Note, there are 64 players in data set.

```{r}
player_id <- as.integer(str_extract(mPlayersAndGames, '\\d+'))

player_name <- str_trim(str_extract(mPlayersAndGames, "[A-Z][^\\|]+")) # assume names start with a letter

player_state <- str_extract(mStatesAndRanks, "[A-Z][A-Z]")             # assume 2-letter abbreviation for State

player_total_points <- as.numeric(str_extract(mPlayersAndGames, "[0-9]+\\.[0-9]"))

player_pre_rating <- as.numeric(str_remove(str_extract(mStatesAndRanks, "R:[ ]+[0-9]{1,}"), "R:[ ]+"))

NROW(player_name)
```

It's a good idea to spot check our static data by comparing with the original. Let's print some values from both original and static data to compare visually:  

> Full names of all players have been successfully extracted. For example, SOFIA ADINA STANESCU-BELLU  
> Player SOFIA ADINA STANESCU-BELLU has 3.5 total points and 1507 pre-rank in original and static data  
> Visual checks pass for other players as well so we are good to go!

```{r sanity-check}
idx <- c(1, 12, 22, 28, 58, 64)
sanity_check <- data.frame(
                    player_name[idx],
                    player_total_points[idx],
                    player_pre_rating[idx]
)

colnames(sanity_check) <- c('name', 'total_points', 'init_rank')

sanity_check

mPlayersAndGames[idx]

mStatesAndRanks[idx]
```

## Missing opponent id

We observe that some games do not contain the id of the opposing player. For example, there is no id of the opposing player for games 6 and 7 played by JULIA SHEN. Similarly, only game 1 played by ASHWIN BALAJI has the opposing player id.  

```{r}
mPlayersAndGames[60]

mPlayersAndGames[62]
```

Visual inspection of the full data shows missing player id for games with codes [H, U, B, X].  

To make downstream processing more robust let's replace missing opposing player ids with NA. After the transformation we observe that missing values have been replaced by NA.

```{r}
mPlayersAndGames <- str_replace_all(mPlayersAndGames, "\\|([HUBX])([ \t\f\n])+", "|\\1\\2 \\N\\A")

mPlayersAndGames[60]

mPlayersAndGames[62]
```

## Data preparation for computing average opponent ranking

Now we extract all opposing player ids into a flattened list. Validate that there are exactly 64 * 7 ids (64 players and 7 games per player) since we made sure that missing ids were replaced by 0. 

```{r}
p_opponent_ids <- as.integer(str_remove(unlist(str_extract_all(mPlayersAndGames, "[A-Z][ ]+([0-9]+|NA)")), "[A-Z][ ]+"))
length(p_opponent_ids) == 64 * 7
```

Scores for exactly 7 games were reported for each player. So we can split opposing player ids into partitions of 7 each. Index into the resulting opponents list is the player id!  

For example, ADITYA BAJAJ has player id 3, so ids of ADITYA's opponents will be found at index 3.

```{r}
p_opponents <- split(p_opponent_ids,                   
                     cut(seq_along(p_opponent_ids),
                     length(mPlayersAndGames),
                     labels = FALSE))

test_id <- 3               # ADITYA's id

mPlayersAndGames[test_id]  # ADITYA's games

p_opponents[test_id]       # ADITYA's opponents
```

## Calculate average rank of opponents for all players

Now we are ready to calculate the average rank of opponents for each player.

* Count the number of opponents, ignoring NA opponent id
* Sum the ranks of all opponents 
* Compute average opponent rank

```{r calculate-avg-opponent-score}
opp_count <- map(p_opponents, 
                 function(x) sum(!is.na(x)))  # count all opponent ids that are not NA

opp_prerating_sum <- map(p_opponents,         # sum pre-rating of all opponents
                         function(x) sum(player_pre_rating[x], 
                                         na.rm = TRUE)) 

opp_avg_prerating <- map2(opp_prerating_sum, # compute player average score
                          opp_count, 
                          ~ round(.x / .y, 0))      

tail(unlist(opp_count,           # opponent count for last 5 players
            use.names = FALSE), 
            5)       
tail(unlist(opp_prerating_sum,   # sum of opponent pre-ratings
            use.names = FALSE), 
            5)   
tail(unlist(opp_avg_prerating,   # average opponent score
            use.names = FALSE), 
            5)   
```

## Create result data frame

Now let's warp all computed attributes into the result data frame.

```{r create-data-frame}
player_opp_avg_prerating <- unlist(opp_avg_prerating) # unlist

result_df <- data.frame(player_id,        # create data.frame
                 player_name, 
                 player_state, 
                 player_total_points, 
                 player_pre_rating, 
                 player_opp_avg_prerating) 

colnames(result_df) <- c('id',              # change column names
                  'name', 
                  'state', 
                  'tot_points', 
                  'pre_rating', 
                  'avg_opponent_pre_rating')
```

Lets take a look at the final results. As sanity check, notice there is data for 64 players.

```{r}
NROW(result_df)
head(result_df, n = 5)
```

## Generate output CSV

Now we can generate the output CSV file in current working directory. No need to generate row names, player ids already start at 1 and increase in increments of 1.

```{r generate-csv}
write.csv(result_df, "player_analysis.csv", row.names = FALSE)
```

