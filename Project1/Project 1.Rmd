---
title: "Project 1"
author: "Jawaid Hakim"
date: "`r Sys.Date()`"
output:
     
  pdf_document: 
    toc: true
    toc_depth: 3
    number_sections: true
  html_document:
    
    toc: true
    toc_depth: 3
    toc_float: true
    number_sections: true
boxlinks: true
urlcolor: blue
always_allow_html: true
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE, warning=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
```

# Solution

## Read tournament data

Read input data. Since we will be extracting rows/columns we can convert to matrix format for easier downstream processing.

```{r load-data}
input_matrix <- read.csv("https://raw.githubusercontent.com/himalayahall/DATA607/main/Project1/tournamentinfo.txt")
input_matrix <- matrix(unlist(input_matrix))
```

## Data preparation

We notice the first 3 rows are headers and do not contain player info.

```{r}
head(input_matrix, n = 10)
```

Skip the 3 header rows.

```{r skip-header-rows}
input_matrix <- input_matrix[-1:-3]
head(input_matrix, n = 6)
```

Data for each player is provided on 2 consecutive rows, followed by a dashed separator line. 1^st^ row contains the player name, total points, and games played by them. The 2^nd^ row contains the State and initial rank of the player. Using this observation, let's split the input matrix into 2 components.  

The 1^st^ component will contain player name, total points, and games played. We can extract this data by starting at row 1 and scooping up every 3^rd^ row from the input matrix.  

```{r extract-players-and-games}
mPlayersAndGames <- input_matrix[seq(1, length(input_matrix), 3)]
head(mPlayersAndGames, n = 5)
```

The 2^nd^ component will contain player State and pre-rating. We extract this data by starting at row 2 and, as before, scooping up every 3^rd^ row from the input matrix.

```{r extract-states-and-ranks}
mStatesAndRanks <- input_matrix[seq(2, length(input_matrix), 3)]
head(mStatesAndRanks, n = 5)
```

## Generate static player data

At this point we have the necessary components to generate static data for each player - player id, name, state, total points, and pre-rating.  

```{r}
player_id <- as.integer(str_extract(mPlayersAndGames, '\\d+'))

player_name <- str_trim(str_extract(mPlayersAndGames, "[A-Z][^\\|]+")) # assume names start with a letter

player_state <- str_extract(mStatesAndRanks, "[A-Z][A-Z]")             # assume 2-letter abbreviation for State

player_total_points <- as.numeric(str_extract(mPlayersAndGames, "[0-9]+\\.[0-9]"))

player_pre_rating <- as.numeric(str_remove(str_extract(mStatesAndRanks, "R:[ ]+[0-9]{1,}"), "R:[ ]+"))

```

It's a good idea to spot check our static data by comparing with the original.  

Let's print some values from both the original and static data to compare visually. Notice that player names have been successfully extracted. For example, a complex name like SOFIA ADINA STANESCU-BELLU has been extracted.  

```{r}
test_idx <- c(1, 12, 22, 28, 58, 64)
sanity_check <- data.frame(
                    player_name[test_idx],
                    player_total_points[test_idx],
                    player_pre_rating[test_idx]
)
colnames(sanity_check) <- c('name', 'total_points', 'init_rank')

sanity_check
```

Next, we see SOFIA ADINA STANESCU-BELLU has 3.5 total points and 1507 in the original data. We validate the original data against our extractions. Success!

```{r}
sofia_idx <- 28 

mPlayersAndGames[sofia_idx]

mStatesAndRanks[sofia_idx]
```

## Missing opponent id

The following codes may appear in a chess cross table:

    W - win, worth 1 point  
    
    L - lose, worth 0 points  
    
    D - draw, worth 0.5 points  
    
    B - full point bye, worth 1 point (given to the left-over player when there are an odd number of players in a tournament round)  
    
    H - half point bye, worth 0.5 points (players can request these when they know they won't be able to make it to certain rounds in a tournament. They are normally only available in the first few rounds of a tournament, and tournament directors often limit a player to a small number of bye requests)  
    
    X - win by forfeit, worth 1 point  
    
    F - lose by forfeit, worth 0 points (and usually results in automatic withdrawal from the rest of the tournament)  
    
    U - unplayed game, worth 0 points (in a round robin, this shows up for any games that haven't been played yet; in a Swiss tournament, this would show up for games following a forfeit loss. This could also show up in a situation where a player requests more byes than the tournament director permitsâ€”the director could allow the player to miss the games without withdrawing from the tournament, but the player would score no points for the missed games)  

We observe that unplayed games (U), byes (B, H), and forfeits (F, U) will not contain opponents ids.  

For example, there is no id of the opposing player for games 5 played by KENNETH J TACK. Game 6 played by VIRAJ MOHILE does not contain the opposing player id. Games 2-7 do not contain opposing player id for ASHWIN BALAJI.

```{r}
kva_idx <- c(12, 58, 62)    # index for KENNETH, VIRAJ, ASHWIN
mPlayersAndGames[kva_idx]

```

Dealing with missing data is always problematic. To make downstream processing more robust, let's replace missing opposing player ids with NA. 

```{r replace-missing-ids}
mPlayersAndGames <- str_replace_all(mPlayersAndGames, "\\|([HUBXF])([ \t\f\n])+", "|\\1\\2 \\N\\A")
```

Validate that missing player ids have indeed been replaced with NA.

```{r}
mPlayersAndGames[kva_idx]

```

## Data preparation for computing average opponent ranking

Now we extract all opposing player ids into a flattened list. Validate there are exactly 64 * 7 ids (64 players, 7 games per player). 

```{r extract-ids}
p_opponent_ids <- as.integer(str_remove(unlist(str_extract_all(mPlayersAndGames, "[A-Z][ ]+([0-9]+|NA)")), "[A-Z][ ]+"))
length(p_opponent_ids) == 64 * 7
```

We can split opposing player ids into equal sized partitions (7 each). Index into the resulting opponents list is the player id!  

For example, ADITYA BAJAJ has player id 3, so ids of ADITYA's opponents will be found at index 3. Visual inspection confirms it is so.

```{r}
p_opponents <- split(p_opponent_ids,                   
                     cut(seq_along(p_opponent_ids),
                     length(mPlayersAndGames),
                     labels = FALSE))

player_id <- 3               # ADITYA's id

mPlayersAndGames[player_id]  # ADITYA's games

p_opponents[player_id]       # ADITYA's opponents
```

## Calculate average rank of opponents for all players

Now we are ready to calculate the average rank of opponents for each player.

    * Count the number of opponents, ignoring NA opponent id
    * Sum the ranks of all opponents 
    * Compute average opponent rank

```{r calculate-avg-opponent-score}
opp_prerating_sum <- map(p_opponents,         # for each player, sum pre-rating of all opponents
                         function(x) sum(player_pre_rating[x], 
                                         na.rm = TRUE)) 

opp_count <- map(p_opponents, 
                 function(x) sum(!is.na(x)))  # for each player, count opponent ids that are not NA

opp_avg_prerating <- map2(opp_prerating_sum, # compute player average score
                          opp_count, 
                          ~ round(.x / .y, 0)) 
```

Let's validate our transformations. As expected, the count of games with opponent ids for KENNETH J TACK, VIRAJ MOHILE, and ASHWIN BALAJI is 6, 6, and 1, respectively.  

```{r}
mPlayersAndGames[kva_idx]

d <- unlist(opp_count, use.names = FALSE)         # opponent counts
d[kva_idx]
```

Visual inspection shows that for games played by KENNETH, the opponent ids are 42, 33, 5, 38, NA, 1, and 3.

```{r}
kenneth_idx <- 12
mPlayersAndGames[kenneth_idx]

```

Let's hand compute the sum and average of KENNETH's opponent rank. The sum of opponent pre-ranks is 9037 and the average is 1506.

```{r}
mPlayersAndGames[kenneth_idx]
mStatesAndRanks[c(42, 33, 5, 38, 1, 3)]

kenneth_sum <- sum(1332, 1449, 1655, 1423, 1794, 1384) # sum of opponent ranks
kenneth_sum

kenneth_avg <- round(kenneth_sum / 6, 0)                     # avg opponent rank
kenneth_avg

```

Let's make sure the hand computed sum/average matches our transformations. It checks out!

```{r}
kenneth_sum == opp_prerating_sum[kenneth_idx]
kenneth_avg == opp_avg_prerating[kenneth_idx]
```

## Create result data frame

Now let's warp all computed attributes into the result data frame.

```{r create-data-frame}
player_opp_avg_prerating <- unlist(opp_avg_prerating, use.names = FALSE) # unlist

result_df <- data.frame(player_id,        # create data.frame
                 player_name, 
                 player_state, 
                 player_total_points, 
                 player_pre_rating, 
                 player_opp_avg_prerating) 

colnames(result_df) <- c('id',              # change column names
                  'name', 
                  'state', 
                  'tot_points', 
                  'pre_rating', 
                  'avg_opponent_pre_rating')
```

Lets take a look at the final results. As final sanity check, notice there is data for 64 players and data for KENNETH matches our earlier validations.

```{r}
head(result_df, n = 5)
NROW(result_df)
result_df[kenneth_idx, ]
```

## Generate output CSV

Now we can generate the output CSV file in current working directory. No need to generate row names, player ids already start at 1 and increase in increments of 1.

```{r generate-csv}
write.csv(result_df, "player_analysis.csv", row.names = FALSE)
```

