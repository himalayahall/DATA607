---
title: "Project 2"
author: "Jawaid Hakim"
date: "`r Sys.Date()`"
output:
  
  html_document:
    
    toc: true
    toc_depth: 3
    toc_float: true
    number_sections: true
  pdf_document: 
    toc: true
    toc_depth: 3
    number_sections: true
boxlinks: true
urlcolor: blue
always_allow_html: true
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
```

# Assignment

## Data set 1 from Jhalak Das

Let's load CSV file containing the data.

```{r load-data}
df1 <- read.csv("jhalak_das.csv")
```

A quick look at the data frame structure identifies some **wider** data characteristics:

1. Terms scores separate columns
1. **sex and age** are concatenated into a single column
1. Personal data of students (name, sex, phone) intermingled with test data

```{r}
str(df1)
head(df1)
```

The analysis for this data set is to tidy it up.  

Let's start by separating **send and age** column into **sex** and **age** columns. Note, during separation we also convert **age** into integer. 

```{r separate-cols}
df1 <- df1 %>%
    separate('sex.and.age', sep = '_', into = c('sex', 'age'), convert = TRUE)
head(df1)
```

Next, we **pivot longer** by collapsing the term column names into a **term** column and putting the values into a **score** column.

```{r pivot-longer}
df1 <- df1 %>%
        pivot_longer(cols = 7:9,
                     names_to = "term",     # col with term names 
                     values_to = "score")   # col with scores
head(df1)
```

Let's clean up strings: uppercase, trim, replace '.' in term data with space.

```{r trim}
df1 <- df1 %>%        
        mutate(name = str_to_upper(str_trim(name))) %>% 
        mutate(sex = str_to_upper(str_trim(sex))) %>%           
        mutate(test.number = str_to_upper(str_trim(test.number))) %>% 
        mutate(term = str_replace(str_to_upper(str_trim(term)), '\\.', ' '))
head(df1)
```

Next, we separate the table into two. 

First table contains personal details of students (id, name, phone, sex).

```{r extract-personal-data}
df1_personal <- df1 %>%
            select(id, name, phone, sex) %>%
            distinct(id, .keep_all = TRUE) %>%
            arrange(id)
head(df1_personal)
```

Second table contains key identifying details of students and test scores (id, name, test.number, term, score). Note, strictly speaking the **id** is sufficient to identify students but also having the **name** in this table is convenient.

```{r extract-test-data}
df1_test <- df1 %>%
            select(id, name, test.number, term, score) %>%
            distinct(id, .keep_all = TRUE) %>%
            arrange(id)
head(df1_test)
```

## Data set 2 from Enid Roman

Original data set at in [salary survey data](https://docs.google.com/spreadsheets/d/1IPS5dBSGtwYVbjsfbaMCYIWnOuRmJcbequohNxCyGVw/edit?resourcekey#gid=1625408792).  

This large data file must be downloaded from  [Github](https://github.com/himalayahall/DATA607/blob/main/Project2/enid_roman.csv) and installed in the current working directory. 

```{r}
df2 <- read.csv("enid_roman.csv")
str(df2)
```

The column headers are descriptive but messy to work with. Let's assign concise column headers.

```{r}
colnames(df2) <- c('timestamp', 
                   'age', 
                   'industry', 
                   'title',
                   'title_context',
                   
                   'annual_salary',
                   'additional_comp',
                   'currency',
                   'currency_other',
                   'income_context',
                   
                   'country',
                   'state_usa',
                   'city',
                   'years_experience_overall',
                   'years_experience_in_field',
                   
                   'highest_education',
                   'gender',
                   'race'
                   )
str(df2)
```

Next, we observe that **age** is a range. Let's take a look at the unique values in age column. We see that age has two problematic values: **under 18** and **65 or over**.

```{r}
unique(df2$age)
```

Let's do the following transformations:

1. Convert **under 18** to 0-18
1. Convert **65 or Over** to 65-150
1. Separate **age** into two columns: age_lower and age_upper

```{r}
df2 <- df2 %>%
        mutate(age = ifelse(age == "under 18", "0-18", age)) %>%
        mutate(age = ifelse(age == "65 or over", "65-150", age)) %>%
        separate(age, into = c('age_lower', 'age_upper'), convert = TRUE)
```

Let's take a look at the unique values in **age_lower** and **age_upper** columns. Successful transformation!

```{r}
unique(df2$age_lower)
unique(df2$age_upper)
```

Now let's take a look at the unique values in columns **years_experience_overall** and **years_experience_in_field**.

```{r}
unique(df2$years_experience_overall)
unique(df2$years_experience_in_field)
```

There are a number of transformations that we can make to **years_experience_overall** and **years_experience_in_field**:

1. Convert **41 years or more** to **41-100**
1. Convert **1 year or less** to **0-1**
1. Remove whitespace and alphabetic characters from all values
1. Separate **years_experience_overall**: years_experience_overall_lower and years_experience_overall_upper
1. Separate **years_experience_in_field**: years_experience_in_field_lower and years_experience_in_field_upper

```{r}
df2 <- df2 %>%
        mutate(years_experience_overall = 
                   ifelse(years_experience_overall == "1 year or less", "0-1", years_experience_overall)) %>%
        mutate(years_experience_overall = 
                   ifelse(years_experience_overall == "41 years or more", "41-100", years_experience_overall)) %>%
        mutate(years_experience_overall = str_remove(years_experience_overall, "years")) %>%
        mutate(years_experience_overall = str_remove_all(years_experience_overall, "\\s+")) %>%
        separate(years_experience_overall, into = c('years_experience_overall_lower', 'years_experience_overall_upper'), convert = TRUE) %>%

        mutate(years_experience_in_field = 
                   ifelse(years_experience_in_field == "1 year or less", "0-1", years_experience_in_field)) %>%
        mutate(years_experience_in_field = 
                   ifelse(years_experience_in_field == "41 years or more", "41-100", years_experience_in_field)) %>%
        mutate(years_experience_in_field = str_remove(years_experience_in_field, "years")) %>%
        mutate(years_experience_in_field = str_remove_all(years_experience_in_field, "\\s+")) %>%
        separate(years_experience_in_field, into = c('years_experience_in_field_lower', 'years_experience_in_field_upper'), convert = TRUE)
```

Verify transformations. Success!

```{r}
unique(df2$years_experience_overall_lower)
unique(df2$years_experience_overall_upper)
unique(df2$years_experience_in_field_lower)
unique(df2$years_experience_in_field_upper)
```

A quick look at **country** column shows a number of issues:

1. Uppercase and lowecase names: e.g. 'denmark', 
1. Misspelling - e.g. 'Nederland', 'Englang', 'united stated'
1. Variations - e.g. 'United States of America', 'united states', 'U.s.a'

```{r}
head(df2$country, n = 20)
```

Fortunately, we can leverage the **countrycode** library to help clean up the country data.

```{r}
library(countrycode)
df2 <- df2 %>%
        mutate(country = countrycode::countryname(country)) %>%
        mutate(country_code = countrycode::countrycode(country, origin = 'country.name', destination = 'iso3c'))
head(df2$country, n = 20)

```

Unfortunately, there is a lot of remaining noise in the country data. For example:

1. ARGENTINA BUT MY ORG IS IN THAILAND - there are two countries mentioned
1. Company in Germany. I work rom Pakistan. - again, two countries mentioned

With greater effort, more cleanup of country names is possible. Left as an exercise for another day!

Final cleanup for this data set is to remove number formatting characters from  **annual_salary** and **additional_comp** columns and convert to numeric. Also add **total_comp** column as sum, of annuial_salary and additional_comp.

```{r}
df2 <- df2 %>%
    mutate(annual_salary = str_remove_all(annual_salary, "[\\s,]+")) %>%
    mutate(annual_salary = as.numeric(annual_salary)) %>%

    mutate(additional_comp = str_remove_all(additional_comp, "[\\s,]+")) %>%
    mutate(additional_comp = as.numeric(additional_comp)) %>%
    
    mutate(total_comp = annual_salary + additional_comp) 
```

The analysis for this data set is to compare salaries by gender and years of experience. Let's find professions with the largest number of observations.

```{r}
df2 %>% 
    filter(currency == 'USD') %>%
    filter(gender %in% c('Man', 'Woman')) %>%
    filter(years_experience_in_field_lower > 1) %>%
    count(title) %>% 
    arrange(desc(n)) %>%
    head(10)
```

To compare salaries by gender and years of experience let's plot a bar chart with the following filters: USD salaries, Man/Woman gender, more than 5 years experience in chosen field, and selected professions.

```{r}
df2 %>%
    filter(currency == 'USD') %>%
    filter(gender %in% c('Man', 'Woman')) %>%
    filter(years_experience_in_field_lower > 1) %>%
    filter(title %in% c('Director',
                        'Senior Software Engineer',
                        'Project Manager',
                        'Program Manager',
                        'Manager',
                        'Software Engineer',
                        'Engineering Manager'
                        )) %>%

    group_by(title, gender) %>%
    summarize(across(c(total_comp), ~ round(mean(.x, na.rm = TRUE), 0))) %>%
    
    ggplot(aes(x = title, y = total_comp, fill=gender)) +  
    ggtitle('Median Salary by Gender') + 
    theme(plot.title = element_text(hjust = 0.5)) +  
    geom_text(aes(label=total_comp), vjust=-0.2,
                            position = position_dodge(0.9), size=3.5) +
                            scale_fill_brewer(palette="Paired") +
    geom_bar(stat="identity", position=position_dodge()) 
```

## Data set 3 from Wilson Ng

Let's load the data set.

```{r}
df3 <- read.csv("wilson_ng.csv")
```

This is a small data set that has the following untidy characteristics:

1. Contains duplicate entries for some fruits - e.g. apple
1. Price of duplicate items is different
1. Current symbol is embedded in price

```{r}
df3
```

Let's cleanup as follows:

1. Remove currency symbol from price, making the assumption that are prices are in USD
1. Convert price to numeric
1. Average price/calories (in case of duplicates)
1. Remove duplicate fruit entries

```{r}
df3 <- df3 %>%
        group_by(item) %>%
        mutate(price = str_remove(price, '\\$')) %>% # remove $ symbol
        mutate(price = as.numeric(price)) %>%        # convert to numeric
        summarize(price = mean(price),               # average price/calories
              calories = mean(calories)) %>%
        arrange(item)
head(df3)
```

Finally, let's do the analysis and find the cheapest fruit(s) with the most calories. Keeping in mind  there may be more than one qualifying fruit, we first select up to 50% items with the lowest price and then select up to 50% items with the highest calories. 

We see that **mango** is the cheapest fruit (not in the USA!) with the highest calories. Bannna is a close second with the same price but lower calories.

```{r}
df3 %>%
    slice_min(price, prop = 1.0) %>%   # find items with min price
                                       # select up to 50% items
    slice_max(calories, prop = 0.5)
```

